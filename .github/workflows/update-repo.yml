name: Update APT Repository

on:
  repository_dispatch:
    types: [package-updated]  # This listens for the event from package repos
  workflow_dispatch:          # Manual trigger
  schedule:
    - cron: '0 6 * * *'        # Daily rebuild
  push:
    branches:
      - main                   # Trigger on push to main branch

jobs:
  update-apt-repo:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Debug repository dispatch
      if: github.event_name == 'repository_dispatch'
      run: |
        echo "Event type: ${{ github.event.action }}"
        echo "Client payload: ${{ toJson(github.event.client_payload) }}"
        echo "Triggered by: ${{ github.event.client_payload.repository }}"

    - name: Parse payload and determine target distribution
      id: payload
      run: |
        # Define supported distributions (single source of truth)
        ALL_DISTRIBUTIONS="stable unstable bookworm-stable bookworm-unstable trixie-stable trixie-unstable"
        echo "all_distributions=$ALL_DISTRIBUTIONS" >> $GITHUB_OUTPUT

        # Extract payload fields (defaults for backward compatibility and scheduled runs)
        DISTRO="${{ github.event.client_payload.distro }}"
        CHANNEL="${{ github.event.client_payload.channel }}"
        COMPONENT="${{ github.event.client_payload.component }}"
        TARGET_REPO="${{ github.event.client_payload.repository }}"

        # Set defaults if not provided
        DISTRO="${DISTRO:-any}"
        CHANNEL="${CHANNEL:-stable}"
        COMPONENT="${COMPONENT:-main}"

        # Normalize distro to lowercase for case-insensitive comparison
        DISTRO=$(echo "$DISTRO" | tr '[:upper:]' '[:lower:]')

        # Map to distribution name
        if [ "$DISTRO" = "any" ]; then
          DISTRIBUTION="$CHANNEL"
        else
          DISTRIBUTION="${DISTRO}-${CHANNEL}"
        fi

        echo "=== Payload Configuration ==="
        echo "Distro: $DISTRO"
        echo "Channel: $CHANNEL"
        echo "Component: $COMPONENT"
        echo "Distribution: $DISTRIBUTION"
        echo "Target Repository: ${TARGET_REPO:-<all repositories>}"

        # Export for later steps
        echo "distro=$DISTRO" >> $GITHUB_OUTPUT
        echo "channel=$CHANNEL" >> $GITHUB_OUTPUT
        echo "component=$COMPONENT" >> $GITHUB_OUTPUT
        echo "distribution=$DISTRIBUTION" >> $GITHUB_OUTPUT
        echo "target_repo=$TARGET_REPO" >> $GITHUB_OUTPUT

        # Determine if this is a targeted update or full rebuild
        if [ -n "$TARGET_REPO" ]; then
          echo "mode=targeted" >> $GITHUB_OUTPUT
          echo "Mode: Targeted update for $TARGET_REPO"
        else
          echo "mode=full" >> $GITHUB_OUTPUT
          echo "Mode: Full repository rebuild"
        fi

    - name: Discover package repositories
      id: discover
      run: |
        echo "Discovering repositories with 'apt-package' topic..."

        # Use GitHub API to find repos with apt-package topic
        repos=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/search/repositories?q=org:hatlabs+topic:apt-package" | \
          jq -r '.items[].full_name')

        echo "Found repositories:"
        echo "$repos"

        # Store for next step
        echo "repos<<EOF" >> $GITHUB_OUTPUT
        echo "$repos" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Setup build environment
      run: |
        sudo apt-get update
        sudo apt-get install -y dpkg-dev apt-utils curl jq gnupg

        # Create packages directory and pool
        mkdir -p packages apt-repo/pool/main

        # Create all distribution directories
        for dist in ${{ steps.payload.outputs.all_distributions }}; do
          echo "Creating distribution: $dist"
          mkdir -p "apt-repo/dists/$dist/main/binary-arm64"
          mkdir -p "apt-repo/dists/$dist/main/binary-all"
        done

        echo "=== Created distribution directories ==="
        ls -la apt-repo/dists/

    - name: Import GPG signing key
      run: |
        echo "${{ secrets.APT_SIGNING_KEY }}" | gpg --import --batch
        # Get the key ID for signing
        GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | head -1 | sed 's/.*\/\([A-Z0-9]*\) .*/\1/')
        echo "GPG_KEY_ID=$GPG_KEY_ID" >> $GITHUB_ENV
        echo "Using GPG key: $GPG_KEY_ID"

    - name: Download packages
      run: |
        MODE="${{ steps.payload.outputs.mode }}"
        TARGET_REPO="${{ steps.payload.outputs.target_repo }}"
        CHANNEL="${{ steps.payload.outputs.channel }}"

        # Function to download packages from a repository
        download_from_repo() {
          local repo=$1
          local release_tag=$2

          echo "=== Processing $repo (release: $release_tag) ==="

          # Get release info
          if [ "$release_tag" = "latest" ]; then
            echo "Fetching latest release from $repo..."
            release_info=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/$repo/releases/latest")
          else
            echo "Fetching release $release_tag from $repo..."
            release_info=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/$repo/releases/tags/$release_tag")
          fi

          # Check if release exists
          if [ "$(echo "$release_info" | jq -r '.message // empty')" = "Not Found" ]; then
            echo "No release found for $repo (tag: $release_tag)"
            return
          fi

          local actual_tag=$(echo "$release_info" | jq -r '.tag_name')
          echo "Release tag: $actual_tag"

          # Download all .deb files from the release
          echo "Downloading .deb files..."
          echo "$release_info" | jq -r '.assets[] | select(.name | endswith(".deb")) | "\(.name)|\(.browser_download_url)"' | \
          while IFS='|' read -r name url; do
            if [ -n "$name" ] && [ -n "$url" ]; then
              echo "Downloading $name..."
              temp_file="packages/temp_$name"
              curl -L --fail -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                   -H "Accept: application/octet-stream" \
                   "$url" -o "$temp_file"

              if [ $? -eq 0 ]; then
                echo "‚úì Downloaded $name"

                # Extract package metadata
                actual_version=$(dpkg-deb --field "$temp_file" Version 2>/dev/null)
                package_name=$(dpkg-deb --field "$temp_file" Package 2>/dev/null)
                architecture=$(dpkg-deb --field "$temp_file" Architecture 2>/dev/null)

                if [ -n "$actual_version" ] && [ -n "$package_name" ] && [ -n "$architecture" ]; then
                  # Create canonical filename
                  correct_filename="${package_name}_${actual_version}_${architecture}.deb"
                  final_path="packages/$correct_filename"

                  mv "$temp_file" "$final_path"

                  echo "  Package: $package_name"
                  echo "  Version: $actual_version"
                  echo "  Architecture: $architecture"
                  echo "  Filename: $correct_filename"
                else
                  echo "  ‚ö†Ô∏è  Could not extract package metadata, keeping original filename"
                  mv "$temp_file" "packages/$name"
                fi
              else
                echo "‚úó Failed to download $name"
                rm -f "$temp_file"
              fi
            fi
          done
          echo ""
        }

        # Determine which repositories and releases to process
        if [ "$MODE" = "targeted" ]; then
          echo "=== Targeted Update Mode ==="
          # Determine release tag based on channel
          if [ "$CHANNEL" = "unstable" ]; then
            RELEASE_TAG="unstable"
          else
            RELEASE_TAG="latest"
          fi

          download_from_repo "$TARGET_REPO" "$RELEASE_TAG"
        else
          echo "=== Full Rebuild Mode ==="
          # Download from all repositories (stable channel only for full rebuild)
          echo "${{ steps.discover.outputs.repos }}" | while IFS= read -r repo; do
            if [ -n "$repo" ]; then
              download_from_repo "$repo" "latest"
            fi
          done
        fi

        echo "=== Downloaded packages ==="
        ls -la packages/ || echo "No packages downloaded"
    - name: Build APT repository structure
      run: |
        MODE="${{ steps.payload.outputs.mode }}"
        TARGET_DIST="${{ steps.payload.outputs.distribution }}"
        COMPONENT="${{ steps.payload.outputs.component }}"

        # Copy new packages to pool
        if ls packages/*.deb 1> /dev/null 2>&1; then
          cp packages/*.deb apt-repo/pool/main/
          echo "Copied $(ls packages/*.deb | wc -l) packages to repository pool"
        else
          echo "No new .deb packages to copy"
        fi

        cd apt-repo

        # Function to build distribution metadata
        build_distribution() {
          local dist=$1
          local component=$2

          echo "=== Building distribution: $dist/$component ==="

          local dist_path="dists/$dist"
          local comp_path="$dist_path/$component"

          # Ensure directories exist
          mkdir -p "$comp_path/binary-arm64"
          mkdir -p "$comp_path/binary-all"

          # Generate Packages files for each architecture
          echo "Generating Packages files..."

          # ARM64 packages
          dpkg-scanpackages -a arm64 pool/ /dev/null > "$comp_path/binary-arm64/Packages" 2>/dev/null || touch "$comp_path/binary-arm64/Packages"
          gzip -kf "$comp_path/binary-arm64/Packages"

          # Architecture-independent packages
          dpkg-scanpackages -a all pool/ /dev/null > "$comp_path/binary-all/Packages" 2>/dev/null || touch "$comp_path/binary-all/Packages"
          gzip -kf "$comp_path/binary-all/Packages"

          # Generate Release file
          echo "Generating Release file for $dist..."
          cd "$dist_path"

          # Determine suite and description based on distribution pattern
          if [[ "$dist" == "stable" ]]; then
            SUITE="stable"
            CODENAME="stable"
            DESC="Hat Labs product packages (stable)"
          elif [[ "$dist" == "unstable" ]]; then
            SUITE="unstable"
            CODENAME="unstable"
            DESC="Hat Labs product packages (unstable - rolling)"
          elif [[ "$dist" =~ ^([a-z0-9]+)-(stable|unstable)$ ]]; then
            # Extract codename and stability from pattern like "bookworm-stable"
            CODENAME="${BASH_REMATCH[1]}"
            STABILITY="${BASH_REMATCH[2]}"
            SUITE="$dist"
            # Capitalize first letter of codename for description
            CODENAME_DISPLAY="$(echo ${CODENAME:0:1} | tr '[:lower:]' '[:upper:]')${CODENAME:1}"
            if [[ "$STABILITY" == "stable" ]]; then
              DESC="Halos packages for Debian $CODENAME_DISPLAY (stable)"
            else
              DESC="Halos packages for Debian $CODENAME_DISPLAY (unstable - rolling)"
            fi
          else
            SUITE="$dist"
            CODENAME="$dist"
            DESC="Hat Labs APT Repository - $dist"
          fi

          cat > Release << EOF
        Origin: Hat Labs
        Label: Hat Labs APT Repository
        Suite: $SUITE
        Codename: $CODENAME
        Version: 1.0
        Architectures: arm64 all
        Components: $component
        Description: $DESC
        Date: $(date -Ru)
        EOF

          # Add package checksums
          apt-ftparchive release . >> Release

          # Sign the Release file
          echo "Signing Release file..."
          gpg --batch --yes --detach-sign --armor -u $GPG_KEY_ID -o Release.gpg Release
          gpg --batch --yes --clear-sign -u $GPG_KEY_ID -o InRelease Release

          cd ../..
          echo "‚úì Built $dist/$component"
        }

        # Determine which distributions to build
        if [ "$MODE" = "targeted" ]; then
          echo "=== Targeted Mode: Updating $TARGET_DIST only ==="
          build_distribution "$TARGET_DIST" "$COMPONENT"
        else
          echo "=== Full Rebuild Mode: Updating stable distributions only ==="
          echo "(Unstable distributions require targeted updates from package repos)"
          # Only build stable distributions in full rebuild mode
          # Unstable distributions get packages from targeted updates when repos push to main
          STABLE_DISTRIBUTIONS="stable bookworm-stable trixie-stable"
          for dist in $STABLE_DISTRIBUTIONS; do
            build_distribution "$dist" "main"
          done
        fi

        echo ""
        echo "=== Repository structure ==="
        find dists -name "Packages" -o -name "Release" | sort

    - name: Export public GPG key
      run: |
        cd apt-repo
        # Export the public key for users to download
        gpg --export --armor $GPG_KEY_ID > hat-labs-apt-key.asc

        # Also create a keyring file
        gpg --export $GPG_KEY_ID > hat-labs-apt-key.gpg

        # Get the fingerprint for the index page
        FINGERPRINT=$(gpg --fingerprint $GPG_KEY_ID | grep -A1 "pub " | tail -n1 | tr -d ' ')
        echo "GPG_FINGERPRINT=$FINGERPRINT" >> $GITHUB_ENV
        echo "Key fingerprint: $FINGERPRINT"

    - name: Create repository index page
      run: |
        cd apt-repo

        # Get package information for index
        package_info=""
        for arch in arm64 armhf all; do
          pkgfile="dists/stable/main/binary-$arch/Packages"
          if [ -f "$pkgfile" ]; then
            awk -v arch="$arch" '
              /^Package:/ { pkg = $2 }
              /^Description:/ { desc = substr($0, 13) }
              /^Filename:/ { file = $2 }
              /^$/ && pkg && desc && file {
                print pkg ":" desc ":" arch ":" file
                pkg = desc = file = ""
              }
            ' "$pkgfile" >> package_info.tmp
          fi
        done
        cat > index.html << EOF
        <!DOCTYPE html>
        <html>
        <head>
            <title>Hat Labs APT Repository</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
                .setup { background: #f8f9fa; padding: 20px; border-radius: 5px; margin: 20px 0; }
                .package { margin: 15px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
                code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; font-family: monospace; }
                .command { background: #2d3748; color: #e2e8f0; padding: 10px; border-radius: 5px; margin: 10px 0; }
                h1 { color: #2d3748; }
                h2 { color: #4a5568; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px; }
                .security { background: #e6fffa; border-left: 4px solid #38b2ac; padding: 15px; margin: 20px 0; }
            </style>
        </head>
        <body>
            <h1>üé© Hat Labs APT Repository</h1>
            <p>Debian packages for Hat Labs projects</p>

            <div class="security">
                <h3>üîê Installation</h3>
                <p>Add our signing key to verify package authenticity:</p>
                <div class="command">curl -fsSL https://apt.hatlabs.fi/hat-labs-apt-key.asc | sudo gpg --dearmor -o /usr/share/keyrings/hatlabs.gpg</div>
                <div class="command">echo "deb [signed-by=/usr/share/keyrings/hatlabs.gpg] https://apt.hatlabs.fi stable main" | sudo tee /etc/apt/sources.list.d/hatlabs.list</div>
                <div class="command">sudo apt update</div>
            </div>

            <h2>üìã Available Packages</h2>
        EOF

        # Add package information
        package_info=""
        for arch in arm64 armhf all; do
          pkgfile="dists/stable/main/binary-$arch/Packages"
          if [ -f "$pkgfile" ]; then
            awk -v arch="$arch" '
              /^Package:/ { pkg = $2 }
              /^Version:/ { ver = $2 }
              /^Description:/ { desc = substr($0, 13) }
              /^Filename:/ { file = $2 }
              /^$/ && pkg && ver && desc && file {
                print pkg ":" ver ":" desc ":" arch ":" file
                pkg = ver = desc = file = ""
              }
            ' "$pkgfile" >> package_info.tmp
          fi
        done

        if [ -f package_info.tmp ] && [ -s package_info.tmp ]; then
          sort package_info.tmp | uniq > package_info_sorted.tmp
          cat package_info_sorted.tmp | awk -F: '
            {
              pkg=$1; ver=$2; desc=$3; arch=$4; file=$5
              key=pkg
              pkgs[key]=desc
              versions[key]=ver
              # Store download links per arch
              links[key,arch]="<a href=\"" file "\">" arch "</a>"
              archlist[key]=archlist[key] ? archlist[key] "," arch : arch
            }
            END {
              PROCINFO["sorted_in"] = "@ind_str_asc"
              for (k in pkgs) {
                printf "<div class=\"package\">\n<h3>%s <small>v%s</small></h3>\n<p>%s</p>\n", k, versions[k], pkgs[k]
                # Print architecture tags as download links
                split(archlist[k], archs, ",")
                printf "<p><strong>Architectures:</strong> "
                for (i=1; i<=length(archs); i++) {
                  a=archs[i]
                  printf "%s", links[k,a]
                  if (i < length(archs)) printf ", "
                }
                printf "</p>\n"
                printf "<div class=\"command\">sudo apt install %s</div>\n</div>\n", k
              }
            }
          ' >> index.html
          rm -f package_info.tmp package_info_sorted.tmp
        else
          cat >> index.html << EOF
            <div class="package">
                <p><em>No packages available yet. Check back soon!</em></p>
            </div>
        EOF
        fi

        cat >> index.html << EOF

            <h2>üîë Manual Key Installation</h2>
            <div class="setup">
                <p>Download the signing key: <a href="hat-labs-apt-key.asc">hat-labs-apt-key.asc</a></p>
                <p>Key fingerprint: <code>$GPG_FINGERPRINT</code></p>
            </div>

            <hr>
            <p><small>Last updated: $(date)</small></p>
            <p><small>Repository URL: <code>https://apt.hatlabs.fi</code></small></p>
            <p><small>üîí This repository is cryptographically signed for security</small></p>
        </body>
        </html>
        EOF

    - name: Deploy to GitHub Pages
      uses: peaceiris/actions-gh-pages@v4
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./apt-repo
        cname: apt.hatlabs.fi

    - name: Report status
      run: |
        echo "=== APT Repository Update Complete ==="
        echo "Repository deployed to: https://apt.hatlabs.fi"
        echo ""
        echo "Distribution Summary:"

        for dist in ${{ steps.payload.outputs.all_distributions }}; do
          pkgfile="apt-repo/dists/$dist/main/binary-arm64/Packages"
          if [ -f "$pkgfile" ]; then
            count=$(grep -c '^Package:' "$pkgfile" 2>/dev/null || echo "0")
            echo "  $dist: $count packages"
          else
            echo "  $dist: (not built this run)"
          fi
        done
